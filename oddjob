#!/usr/bin/env ruby

# Copyright (c) 2010-2016 Mike Fellows (https://github.com/MCF)

require 'webrick'

module OddJob

  VERSION = '1.5.0'
  UPLOAD_PATH = '/oj_upload'
  INFO_PATH = '/oj_info'
  DEFAULT_PORT = 4400

  def OddJob.server(opts)
    defaults = {
      :serverroot     => ".",
      :savedirectory  => nil,
      :usagemessage   => nil,
      :allowall       => false,
      :networkdelay   => 0,
      :port           => DEFAULT_PORT
    }

    options = defaults.merge(opts)

    # Add missing MIME types if needed (http://bugs.ruby-lang.org/issues/5365)
    m_types = WEBrick::HTTPUtils::DefaultMimeTypes.dup
    m_types['js']  = 'application/javascript' unless m_types.has_key?('js')
    m_types['svg'] = 'image/svg+xml'          unless m_types.has_key?('svg')

    s = WEBrick::HTTPServer.new(
      :Port          =>  options[:port],
      :BindAddress   =>  options[:ipaddress],
      :BindAddress   =>  options[:allowall] ? '0.0.0.0' : '127.0.0.1',
      :MimeTypes     =>  m_types,
      :DocumentRoot  =>  options[:serverroot]
    )

    s.mount(
      INFO_PATH,
      Info,
      options[:usagemessage]
    )
    s.mount(
      UPLOAD_PATH,
      FileUpload,
      options[:networkdelay],
      options[:savedirectory]
    )

    ['TERM', 'INT'].each { |signal| trap(signal){ s.shutdown } }

    s.start
  end

  module HtmlWrapper
    def page(content, title)
      [
        "<!DOCTYPE html>",
        "<head>",
        "  <title>OJ #{title}</title>",
        "  <style>",
        "  body {font:100% arial,sans-serif; margin:4em 5em}",
        "  a {text-decoration:none; color:rgb(248,143,6)}",
        "  a:hover {color:rgb(248,179,76);}",
        "  </style>",
        "</head>",
        "<html><body>",
        content,
        "</body></html>",
      ].join("\n")
    end
  end

  class Info < WEBrick::HTTPServlet::AbstractServlet
    include HtmlWrapper

    def initialize(server, cmd_usage, *options)
      @usage = cmd_usage
      super(server, options)
    end

    def do_GET(request, response)
      response.status = 200
      response['Content-Type'] = "text/html"
      response.body = info_page
    end

    protected 

    def info_page
      html = [
        "  <h1>#{File.basename($0)}</h1>",
        "  <p>Version: <strong>#{VERSION}</strong></p>"
      ]
      html << "  <pre>#{@usage}</pre>" unless @usage.nil?
      page(html.join("\n"), "Info")
    end

  end

  class FileUpload < WEBrick::HTTPServlet::AbstractServlet
    include HtmlWrapper

    def initialize(server, delay, save_directory, *options)
      @simulated_delay = delay
      @save_directory = save_directory
      super(server, options)
    end

    def do_POST(request, response)

      # If there is no save directory specified, then the file upload request
      # and contents will be displayed on the server's stdout.
      if @save_directory.nil?
        puts "\n++ File Upload POST request to this server was:\n"
        puts request
        puts "++ end File Upload POST request\n\n"
      end

      all_files = Array.new
      ['file', 'file[]'].each do |name|
        if request.query[name]
          request.query[name].each_data do |data|

            all_files.push(data.filename)

            # No save directory? Then print out each file's contents.
            if @save_directory.nil?
              puts "** Contents of: #{data.filename} ---"
              puts data.to_s
              puts "** end contents of: #{data.filename} ---\n\n"
            else
              output_name = unique_name(data.filename, @save_directory)
              File.open(output_name, "w"){|f| f.print(data.to_s)}

              puts "\n#{data.filename} Uploaded to: #{output_name}\n"
            end
          end
        end
      end

      response.status = 200
      response['Content-type'] = 'text/html'
      response.body = uploaded_page(all_files)

      sleep(@simulated_delay)
    end

    def do_GET(request, response)
      response.status = 200
      response['Content-type'] = 'text/html'
      response.body = uploader_page
    end

    protected

    # Find a unique name in the same directory for the given file.
    #
    # If the desired name is not available it adds an index to the base name of
    # the file until one is found.  For example if test.txt already existed
    # then it would try test_1.txt, test_2.txt and so on.
    def unique_name(desired_name, save_directory)
      ext = File.extname(desired_name)
      base = File.basename(desired_name, ext)

      final_base = full_base = File.join(save_directory, base)
      i = 1
      while(File.exist?(final_base + ext))
        final_base = "#{full_base}_#{i}"
        i += 1
      end

      final_base + ext
    end

    def uploader_page
      html = [
        "<h1>Uploader</h1>",
        "<form action='' method='POST' enctype='multipart/form-data'>",
        "  <p>",
        "    Select file(s) to upload:",
        "    <br><br>",
        "    <input type='file' name='file' multiple='true'>",
        "    <br><br>",
        "    <input type='submit'>",
        "  </p>",
        "</form>",
      ].join("\n")

      page(html, "Uploader")
    end

    def uploaded_page(names)
      html = [
        "<h1>Results</h1>",
        "<p>Uploaded:",
        "  <strong>#{names.join("</strong>, <strong>")}</strong>",
        "</p>",
        "<p><a href=''>Return to upload page</a></p>",
      ].join("\n")

      page(html, "Upload Results")
    end
  end

end


if __FILE__ == $0

  def show_version()
    STDOUT.puts("Version: #{OddJob::VERSION}")
    exit
  end

  def error(msg, suggest_usage=false)
    STDERR.puts("ERORR: #{msg}")
    STDERR.puts(" try the -h option for the command usage") if suggest_usage
    exit 1
  end

  require 'optparse'

  opts = {}

  optparser = OptionParser.new do |o|
    o.banner =  "Usage: #{File.basename($0)} [OPTIONS] [server_root]"
    o.separator <<TXT

Where the optional server_root is to be served as the server's root directory.
The default server root is the current working directory.

The default file upload behaviour is to print the contents of the HTTP POST,
and the contents of any uploaded files, will to the server's STDOUT.  It is
recommended that you only upload text files in this case.

If an output directory is specified all uploaded files are saved under their
own names in this directory.  Pre-existing files are not overwritten, instead a
number is added to the end of the new files names when saving.

If a simulated network delay is specified the server will pause that many
seconds before returning a response for file(s) uploaded to the file upload
path: #{OddJob::UPLOAD_PATH}.

The server will only respond to clients on localhost unless the --allhosts
option is specified.  Be aware of the security implications of allowing any
other host on your network to connect to the server if you use this option.

An informational page is available at the #{OddJob::INFO_PATH} path.

The default server port is #{OddJob::DEFAULT_PORT}.

TXT

    o.on('-d', '--delay=value', Float,
         'File upload simulated network delay') { |x| opts[:networkdelay] = x }
    o.on('-a', '--allhosts',
         'Allow connections from all hosts')    { opts[:allowall] = true }
    o.on('-o', '--output=value', String,
         'Directory to save uploaded files')    { |x| opts[:savedirectory] = x }
    o.on('-p', '--port=value', Integer,
         "Web server port to use")              { |x| opts[:port] = x }
    o.on('--version',
         'Display the version number and exit') { show_version() }

    o.separator("")

    o.on('-h', '--help', 'Display this message') {puts(o); exit}
  end

  theRest = []
  begin
    theRest =  optparser.parse(ARGV)
  rescue
    error($!.to_s, true)
  end

  error("too many arguments given", true) if theRest.size > 1

  if theRest.size == 1
    opts[:serverroot] = theRest.pop

    unless File.directory?(opts[:serverroot])
      error([
        "directory to serve does not exist or is not ",
        "a directory: #{opts[:serverroot]}"
      ].join(''))
    end

    if opts[:savedirectory] and not File.directory?(opts[:savedirectory])
      error([
        "output directory does not exist or is not ",
        "a directory: #{opts[:savedirectory]}"
      ].join(''))
    end
  end

  if opts.has_key?(:port) and (opts[:port] < 0 or opts[:port] > 65535)
    error("port specified is invalid: #{opts[:port]}")
  end

  if opts.has_key?(:networkdelay) and opts[:networkdelay] < 0
    error("simulated delay cannot be negative: #{opts[:networkdelay]}")
  end

  opts[:usagemessage] = optparser.to_s

  begin
    OddJob.server(opts)
  rescue Errno::EADDRINUSE => e
    error([
      "Could not bind to the given port and address, often this happens when",
      "some other process is already using the selected port: #{opts[:port]}"
    ].join("\n"))
  end
end
