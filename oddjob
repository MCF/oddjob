#!/usr/bin/ruby

# Copyright (c) 2010-2016 Mike Fellows

require 'webrick'

module OddJob

  VERSION = "1.4.0"

  def OddJob.server(options)

    # Add missing MIME types (http://bugs.ruby-lang.org/issues/5365)
    m_types = WEBrick::HTTPUtils::DefaultMimeTypes.dup
    m_types["js"]  = "application/javascript" unless m_types.has_key?("js")
    m_types["svg"] = "image/svg+xml"          unless m_types.has_key?("svg")

    s = WEBrick::HTTPServer.new(
      :Port          =>  options[:port],
      :BindAddress   =>  options[:ipaddress],
      :MimeTypes     =>  m_types,
      :DocumentRoot  =>  options[:directorytoserve]   # Root directory.
    )

    s.mount(
      "/oddjob_info",
      Info,
      options[:usagemessage]
    )

    s.mount(
      "/oddjob_upload",
      FileUpload,
      options[:simulatednetworkdelay],
      options[:outputdirectory]
    )

    ['TERM', 'INT'].each {|signal| trap(signal){s.shutdown} }

    s.start
  end

  module HtmlWrapper

    def page(content, title)
      [
        "<!DOCTYPE html>",
        "<head>",
        "  <title>OJ #{title}</title>",
        "  <style>",
        "  body {font:100% arial,sans-serif; margin:4em 5em}",
        "  a {text-decoration:none; color:rgb(248,143,6)}",
        "  a:hover {color:rgb(248,179,76);}",
        "  </style>",
        "</head>",
        "<html><body>",
        content,
        "</body></html>",
      ].join("\n")
    end

  end

  class Info < WEBrick::HTTPServlet::AbstractServlet

    include HtmlWrapper

    def initialize(server, cmd_usage, *options)
      @usage = cmd_usage
      super(server, options)
    end

    def do_GET(request, response)
      response.status = 200
      response['Content-Type'] = "text/html"
      response.body = info_page
    end

    private

    def info_page
      html = [
        "  <h1>#{File.basename($0)}</h1>",
        "  <p>Version: <strong>#{VERSION}</strong></p>"
      ]
      html << "  <pre>#{@usage}</pre>" unless @usage.nil?
      page(html.join("\n"), "Info")
    end
  end

  class FileUpload < WEBrick::HTTPServlet::AbstractServlet

    include HtmlWrapper

    def initialize(server, delay, save_directory, *options)
      @simulated_delay = delay
      @save_directory = save_directory
      super(server, options)
    end

    def do_POST(request, response)

      # If there is no save directory specified, then the file upload request
      # and contents will be displayed on the server's stdout.
      if @save_directory.nil?
        puts "\n++ File Upload POST request to this server was:\n"
        puts request
        puts "++ end File Upload POST request\n\n"
      end

      all_files = Array.new
      ["file", "file[]"].each do |name|
        if request.query[name]
          request.query[name].each_data do |data|

            all_files.push(data.filename)

            # No save directory? Then print out each file's contents.
            if @save_directory.nil?
              puts "** Contents of: #{data.filename} ---"
              puts data.to_s
              puts "** end contents of: #{data.filename} ---\n\n"
            else
              output_name = unique_name(data.filename, @save_directory)
              File.open(output_name, "w"){|f| f.print(data.to_s)}

              puts "\n#{data.filename} Uploaded to: #{output_name}\n"
            end
          end
        end
      end

      response.status = 200
      response['Content-type'] = "text/html"
      response.body = uploaded_page(all_files)

      sleep(@simulated_delay)
    end

    def do_GET(request, response)
      response.status = 200
      response['Content-type'] = "text/html"
      response.body = uploader_page
    end

    protected

    # Find a unique name in the same directory for the given file.
    #
    # If the desired name is not available it adds an index to the base name of
    # the file until one is found.  For example if test.txt already existed
    # then it would try test_1.txt, test_2.txt and so on.
    def unique_name(desired_name, save_directory)
      ext = File.extname(desired_name)
      base = File.basename(desired_name, ext)

      final_base = full_base = File.join(save_directory, base)
      i = 1
      while(File.exist?(final_base + ext))
        final_base = "#{full_base}_#{i}"
        i += 1
      end

      final_base + ext
    end

    private

    def uploader_page
      html = [
        "<h1>Uploader</h1>",
        "<form action='' method='POST' enctype='multipart/form-data'>",
        "  <p>",
        "    Select file(s) to upload:",
        "    <br><br>",
        "    <input type='file' name='file' multiple='true'>",
        "    <br><br>",
        "    <input type='submit'>",
        "  </p>",
        "</form>",
      ].join("\n")

      page(html, "Uploader")
    end

    def uploaded_page(names)
      html = [
        "<h1>Results</h1>",
        "<p>Uploaded:",
        "  <strong>#{names.join("</strong>, <strong>")}</strong>",
        "</p>",
        "<p><a href=''>Return to upload page</a></p>",
      ].join("\n")

      page(html, "Upload Results")
    end
  end

end


if __FILE__ == $0

  def show_version()
    STDOUT.puts("Version: #{OddJob::VERSION}")
    exit
  end

  def error(msg, suggest_usage=false)
    STDERR.puts("ERORR: #{msg}")
    STDERR.puts(" try the -h option for the command usage") if suggest_usage
    exit 1
  end

  require 'optparse'

  opts = {
    :directorytoserve =>      ".",
    :outputdirectory =>       nil,
    :usagemessage =>          nil,
    :ipaddress =>             "127.0.0.1",
    :simulatednetworkdelay => 0,
    :port =>                  2345
  }

  optparser = OptionParser.new do |o|
    o.banner =  "Usage: #{File.basename($0)} [OPTIONS] [directory_to_serve]"
    o.separator <<TXT

Where directory_to_serve is the name of the directory that will be served up as
the web server's root directory.  If no directory is given a default of the
current working directory will be used.

If an output directory is given the uploaded files are saved under their own
names in the output directory.  Any pre-existing files are not overwritten,
instead a number is added to the end of the file name of any newer duplicate
files.

If an output directory is not specified then uploaded files will not be saved,
instead the contents of the HTTP POST, and the contents of any uploaded files,
will be printed to the server's STDOUT.

If a simulated network delay is specified then the server will pause that many
seconds before sending a response for any file uploaded to the standard file
upload URL "/oddjob_upload"

There is also an informational page (that includes this usage message) located
at the URL "/oddjob_info"

The default port is #{opts[:port]}, and the default is for the server to serve
content only on localhost.  If you need to connect to your oddjob server from
another host then use the -a option, but be aware of the security implications
of allowing any other host to connect to your server.

TXT

    o.on('-d', '--delay=value', Float,
         'Simulated network delay in seconds')    {|x| opts[:simulatednetworkdelay] = x}
    o.on('-a', '--allhosts',
         'Allow connections from all hosts')      {opts[:ipaddress] = '0.0.0.0'}
    o.on('-o', '--output=value', String,
         'Directory to hold any uploaded files')  {|x| opts[:outputdirectory] = x}
    o.on('-p', '--port=value', Integer,
         'Port that web server should listen on') {|x| opts[:port] = x}
    o.on('--version',
         'Display the version number and exit')   {show_version()}

    o.separator("")

    o.on('-h', '--help', 'Display this message') {puts(o); exit}
  end

  theRest = []
  begin
    theRest =  optparser.parse(ARGV)
  rescue
    error($!.to_s, true)
  end

  error("too many arguments given", true) if theRest.size > 1

  opts[:directorytoserve] = theRest.pop if theRest.size == 1

  unless File.directory?(opts[:directorytoserve])
    error([
      "directory to serve does not exist or is not ",
      "a directory: #{opts[:directorytoserve]}"
    ].join(''))
  end

  if opts[:outputdirectory] and not File.directory?(opts[:outputdirectory])
    error([
      "output directory does not exist or is not ",
      "a directory: #{opts[:outputdirectory]}"
    ].join(''))
  end

  if opts[:port] < 0 or opts[:port] > 65535
    error("port specified is invalid: #{opts[:port]}")
  end

  if opts[:simulatednetworkdelay] < 0
    error("simulated delay cannot be negative: #{opts[:simulatednetworkdelay]}")
  end

  opts[:usagemessage] = optparser.to_s

  begin
    OddJob.server(opts)
  rescue Errno::EADDRINUSE => e
    error([
      "Could not bind to the given port and address, often this happens when",
      "some other process is already using the selected port: #{opts[:port]}"
    ].join("\n"))
  end
end
